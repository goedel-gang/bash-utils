# vim: ft=sh

# FIGMENTIZE: prompt
#                                          __
# ______ _______   ____    _____  ______ _/  |_
# \____ \\_  __ \ /  _ \  /     \ \____ \\   __\
# |  |_> >|  | \/(  <_> )|  Y Y  \|  |_> >|  |
# |   __/ |__|    \____/ |__|_|  /|   __/ |__|
# |__|                         \/ |__|

# file that sets up my flashy bashy prompt
# This file was taken from
# https://github.com/goedel-gang/dotfiles/commit/7db604534dc08672d5a6a4a5ca42968ee9398dbc
# and has had some bits lopped off to make it more stand-alone. See the original
# for a vi-mode indicator and Git information in the prompt.
# This one is mostly to provide a prompt with some colours, basic information
# and an apparix component.

# here follow a set of functions I have defined to compartmentalise my prompt a
# little. They make heavy use of ANSI terminal codes and \[ \], which are used
# to make colours/other styling like bolding, and indicate to Bash that they are
# non-printing, respectively.
# I have hardcoded all the ANSI escape codes for performance reasons - it seems
# to offer a speedup of over 50%, which is worthwile. The tput command used to
# obtain the sequence is also provided as a comment.
# Vim tput hardcoding macro (acts on next match of $(tput[^)]*)
# :let @q = "/\\$(tput[^)]*)\<CR>ft\"ayi(cgn\<C-r>\<C-r>=system(\"\<C-r>a\")\<CR>\<Esc>"
# initialise using 0fly$:<C-r><C-r>"<CR>
# fix escape sequences with :%s/<C-v>x1b/\\e/g (you have to type the proper
# sequences yourself)

# The two remaining targets for optimisation are probably reducing function
# overhead (that is, making the whole thing one disgusting, illegible,
# unmodifiable one-liner) and the apparix_prompt function, which takes a fair
# amount of time. See prompt_profile() later on.

# function which returns a code to make text green if exit status was
# successful, and red otherwise. Indicates the value of a non-zero return
# status. TAKES AN ARGUMENT
exitstatus_prompt() {
    if [[ "$1" == 0 ]]; then
        # echo -n "\[$(tput setaf 2)\]@"
        echo -n "\[\e[38;5;2m\]@"
    else
        # echo -n "\[$(tput setaf 1)\]($1)"
        echo -n "\[\e[38;5;1m\]($1)"
    fi
}

# function to format a nice SHLVL indicating prompt component, to warn about
# nested shells.
shlvl_prompt() {
    if [[ "$SHLVL" = 1 ]]; then
        # echo -n "\[$(tput setaf 7)\]|"
        echo -n "\[\e[38;5;7m\]|"
    else
        # echo -n "\[$(tput setaf 7)\][$SHLVL]"
        echo -n "\[\e[38;5;7m\][$SHLVL]"
    fi
}

# function which returns red if the user has root privileges, and pink otherwise
user_prompt() {
    if [[ $EUID -ne 0 ]]; then
        # echo -n "\[$(tput setaf 5)\]\u"
        echo -n "\[\e[38;5;5m\]\u"
    else
        # echo -n "\[$(tput setaf 1)\]\1"
        echo -n "\[\e[38;5;1m\]\1"
    fi
}

# function to return the last two components of PWD, stijn style, with some
# extra formatting.
# UNUSED: I personally just whack my full PWD into my prompt, with
# full_dir_prompt
dir_prompt() {
    # a little logic to make directory behave correctly in / and /*/, and also
    # handle home directory with a little extra logic
    local iz_dir_base="$(basename "$PWD")"
    local iz_dir_dir="$(basename "$(dirname "$PWD")")"
    if [[ "$PWD" = "$HOME" ]]; then
        local iz_dir="~"
    elif [[ "$(dirname "$PWD")" = "$HOME" ]]; then
        local iz_dir="~/$iz_dir_base"
    elif [[ "$iz_dir_base" = "/" ]]; then
        local iz_dir="/"
    elif [[ "$iz_dir_dir" = "/" ]]; then
        local iz_dir="/$iz_dir_base"
    else
        local iz_dir="$iz_dir_dir/$iz_dir_base"
    fi
    # echo -n "\[$(tput setaf 6)\]$iz_dir"
    echo -n "\[\e[38;5;6m\]$iz_dir"
}

# display PWD in full.
# I prefer this version because
# 1) I have space to kill as I use a two-line prompt
# 2) It's much faster - dir_prompt is a performance bottleneck, as profiled
#    later on
full_dir_prompt() {
    # uses dirs +0 to display ~ in place of eg /home/izaak
    # echo -n "\[$(tput setaf 6)\]$(dirs +0)"
    echo -n "\[\e[38;5;6m\]$(dirs +0)"
}

# function to display the host name
host_prompt() {
    # echo -n "\[$(tput setaf 3)\]\h"
    echo -n "\[\e[38;5;3m\]\h"
}

# function to display an apparix bookmark if you're in one.
# This is a little bit of a performance bottleneck, as indicated by
# prompt_profile. As far as I can see there aren't any really trivial
# optimisations left, and as it stands it's about 2-3 times slower than any
# other component (ignoring dir_prompt)
apparix_prompt() {
    # assume that amibm has empty output if it's unsuccessful, to avoid having
    # to re-run it
    local izaak_bm="$(amibm)"
    if [[ -n "$izaak_bm" ]]; then
        # echo -n " \[$(tput setaf 4)\]($izaak_bm)"
        echo -n " \[\e[38;5;4m\]($izaak_bm)"
    fi
}

# function to build a pretty looking prompt, inspired by Stijn van Dongen's
# taste in prompts, but with more colours.
izaak_prompt() {
    # it's important that this goes first, in order to get the exit status
    # before it runs out
    local IZAAK_EXIT_STATUS="$?"
    # some prompt-escaped terminal codes for ease of reference
    # local iz_bold="\[$(tput bold)\]"
    # local iz_reset="\[$(tput sgr0)\]"
    local iz_bold="\[\e[1m\]"
    local iz_reset="\[\e[m\e(B\]"
    # construct the prompt from all the earlier components
    local iz_prompt="$iz_bold$(user_prompt)$(exitstatus_prompt "$IZAAK_EXIT_STATUS")$(host_prompt)$(shlvl_prompt)$(full_dir_prompt)$(apparix_prompt)$iz_reset"

    PS1=$'\n'"$iz_prompt"$'\n'" $iz_bold\[\e[38;5;7m\]->$iz_reset "
}

PROMPT_COMMAND='izaak_prompt'

# small function to do a very simple profile of the different prompt components
prompt_profile() {
    LOOPS=200
    echo "Profiling each component with $LOOPS loops"
    for component in izaak_prompt user_prompt exitstatus_prompt host_prompt\
        shlvl_prompt full_dir_prompt dir_prompt apparix_prompt; do
        echo
        echo -n "$component..."
        time for ((i=0; i<LOOPS; i++)); do
            # mock some arguments for the component that want them
            silent "$component" 1 1
        done
    done
}
